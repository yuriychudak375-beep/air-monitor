<!DOCTYPE html>
<html lang="uk">
<head>
  <meta charset="UTF-8" />
  <title>Air Monitor — Viewer</title>
  <link rel="stylesheet" href="https://unpkg.com/leaflet/dist/leaflet.css" />

  <style>
    html, body {
      margin: 0;
      padding: 0;
      width: 100%;
      height: 100%;
      overflow: hidden;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
    }
    body.dark { background: #050608; color: #eee; }
    body.light { background: #f2f2f2; color: #111; }

    #map {
      width: 100vw;
      height: 100vh;
    }

    #hud {
      position: fixed;
      top: 10px;
      left: 10px;
      z-index: 1000;
      background: rgba(0,0,0,0.6);
      color: #fff;
      padding: 6px 10px;
      border-radius: 8px;
      font-size: 13px;
      backdrop-filter: blur(6px);
    }
    body.light #hud {
      background: rgba(255,255,255,0.8);
      color: #111;
    }
    #clock {
      font-weight: 600;
      margin-bottom: 4px;
    }
    #themeToggle {
      border: none;
      border-radius: 999px;
      padding: 4px 10px;
      font-size: 12px;
      cursor: pointer;
      background: #2d6cff;
      color: #fff;
    }
    body.light #themeToggle {
      background: #222;
      color: #fff;
    }
  </style>
</head>
<body class="dark">
  <div id="map"></div>

  <div id="hud">
    <div id="clock">--:--:--</div>
    <button id="themeToggle">Світла тема</button>
  </div>

  <script src="https://unpkg.com/leaflet/dist/leaflet.js"></script>

  <script>
    // ===== КАРТА =====
    const map = L.map("map").setView([49, 31], 6);

    const tilesLight = L.tileLayer("https://tile.openstreetmap.org/{z}/{x}/{y}.png", {
      maxZoom: 10,
      minZoom: 4,
      attribution: "&copy; OpenStreetMap"
    });

    const tilesDark = L.tileLayer(
      "https://{s}.basemaps.cartocdn.com/dark_all/{z}/{x}/{y}{r}.png",
      {
        maxZoom: 10,
        minZoom: 4,
        subdomains: "abcd",
        attribution: "&copy; OpenStreetMap, &copy; CartoDB"
      }
    );

    let isDark = true;
    tilesDark.addTo(map);

    const clockEl = document.getElementById("clock");
    function updateClock() {
      const now = new Date();
      clockEl.textContent = now.toLocaleString("uk-UA", {
        timeZone: "Europe/Kyiv",
        day: "2-digit",
        month: "2-digit",
        year: "numeric",
        hour: "2-digit",
        minute: "2-digit",
        second: "2-digit"
      });
    }
    updateClock();
    setInterval(updateClock, 1000);

    const themeBtn = document.getElementById("themeToggle");
    themeBtn.onclick = () => {
      if (isDark) {
        map.removeLayer(tilesDark);
        tilesLight.addTo(map);
        isDark = false;
        document.body.classList.remove("dark");
        document.body.classList.add("light");
        themeBtn.textContent = "Темна тема";
      } else {
        map.removeLayer(tilesLight);
        tilesDark.addTo(map);
        isDark = true;
        document.body.classList.remove("light");
        document.body.classList.add("dark");
        themeBtn.textContent = "Світла тема";
      }
    };

    // ===== РАЙОНИ / ПІДСВІЧУВАННЯ ТРИВОГ =====

    // Шар з районами і мапа "ключ → polygon layer"
    let raionLayer = null;
    const raionByKey = new Map();
    const activeAlertLayers = new Set();

    function baseRaionStyle() {
      return {
        color: "#666",
        weight: 1,
        fillColor: "#000",
        fillOpacity: 0.05
      };
    }

    // Нормалізація назв для порівняння
    function normalizeName(str) {
      return String(str)
        .toLowerCase()
        .replace(/[«»"']/g, "")
        .replace(/\s+район/g, "")
        .replace(/\s+область/g, "")
        .replace(/\s+місто/g, "")
        .replace(/\s+/g, " ")
        .trim();
    }

    // Витягнути красиву назву району з properties
    function getFeatureLabel(feature) {
      const p = feature.properties || {};
      return (
        p.location_title ||
        p.name_ua ||
        p.NAME_UA ||
        p.name ||
        p.NAME ||
        p.raion_ua ||
        p.RAYON_UA ||
        p.RAYON ||
        ""
      );
    }

    // З одного feature робимо кілька можливих ключів
    function getFeatureKeys(feature) {
      const p = feature.properties || {};
      const keys = [];

      if (p.location_uid != null) keys.push("uid:" + String(p.location_uid));
      if (p.location_oblast_uid != null) keys.push("uid:" + String(p.location_oblast_uid));
      if (p.uid != null) keys.push("uid:" + String(p.uid));
      if (p.id != null) keys.push("uid:" + String(p.id));

      const label = getFeatureLabel(feature);
      if (label) keys.push("name:" + normalizeName(label));

      const oblName = p.oblast || p.oblast_ua || p.OBLAST_UA;
      if (oblName) keys.push("name:" + normalizeName(oblName));

      return keys;
    }

    // Перетворюємо сирі дані тривог у масив об’єктів
    function normalizeAlertList(raw) {
      if (!Array.isArray(raw)) return [];
      if (raw.length && typeof raw[0] === "string") {
        // Якщо сервер шле просто ["Львівський район", ...]
        return raw.map(name => ({ location_title: name }));
      }
      return raw;
    }

    function buildAlertKeys(alert) {
      const keys = [];
      const uid = alert.location_uid ?? alert.location_id ?? alert.id;
      const oblUid = alert.location_oblast_uid;

      if (uid != null) keys.push("uid:" + String(uid));
      if (oblUid != null) keys.push("uid:" + String(oblUid));

      if (alert.location_title) keys.push("name:" + normalizeName(alert.location_title));
      if (alert.location_raion) keys.push("name:" + normalizeName(alert.location_raion));
      if (alert.location_oblast) keys.push("name:" + normalizeName(alert.location_oblast));

      return keys;
    }

    function clearAlertHighlight() {
      activeAlertLayers.forEach(layer => {
        layer.setStyle(baseRaionStyle());
      });
      activeAlertLayers.clear();
    }

    function applyAlertsFromServer(rawAlerts) {
      if (!raionLayer) return;

      const alerts = normalizeAlertList(rawAlerts);
      clearAlertHighlight();

      alerts.forEach(a => {
        // Можна фільтрувати тільки "air_raid", якщо треба
        // if (a.alert_type && a.alert_type !== "air_raid") return;

        const keys = buildAlertKeys(a);
        keys.forEach(k => {
          const layer = raionByKey.get(k);
          if (!layer) return;
          if (activeAlertLayers.has(layer)) return;

          layer.setStyle({
            color: "#ff5252",
            weight: 2,
            fillColor: "#ff1744",
            fillOpacity: 0.4
          });
          activeAlertLayers.add(layer);
        });
      });
    }

    // Щоб ти міг тестити з консолі:
    // window.debugApplyAlerts([{ location_title: "Сумський район" }])
    window.debugApplyAlerts = applyAlertsFromServer;

    // Завантажуємо rayony.geojson
    fetch("rayony.geojson")
      .then(r => r.json())
      .then(geo => {
        raionLayer = L.geoJSON(geo, {
          style: baseRaionStyle,
          onEachFeature: (feature, layer) => {
            const keys = getFeatureKeys(feature);
            keys.forEach(k => {
              if (!raionByKey.has(k)) {
                raionByKey.set(k, layer);
              }
            });

            const label = getFeatureLabel(feature);
            if (label) {
              layer.bindPopup(label);
            }
          }
        }).addTo(map);
      })
      .catch(err => {
        console.warn("Не вдалось завантажити rayony.geojson:", err);
      });

    // ===== МОДЕЛЬКИ =====
    const MODEL_PNG = {
      x101: "models/x101.png",
      shahed: "models/shahed.png",
      iskander: "models/iskander.png",
      kalibr: "models/kalibr.png"
    };

    // Якщо якась моделька трошки криво, підкрутиш тут
    const ROT_OFFSET = {
      x101: -45,
      shahed: 0,
      iskander: 0,
      kalibr: 0
    };

    function createMarker(t) {
      const div = document.createElement("div");
      div.style.width = "60px";
      div.style.height = "60px";
      div.style.display = "flex";
      div.style.alignItems = "center";
      div.style.justifyContent = "center";

      const img = document.createElement("img");
      img.src = MODEL_PNG[t.type] || MODEL_PNG["x101"];
      img.style.width = "100%";
      img.style.height = "100%";
      img.style.objectFit = "contain";
      img.style.transformOrigin = "center";
      img.style.transition = "transform 0.15s linear";

      div.appendChild(img);

      const icon = L.divIcon({
        className: "",
        html: div,
        iconSize: [60, 60],
        iconAnchor: [30, 30]
      });

      const marker = L.marker([t.lat, t.lon], { icon });
      marker._imgRef = img;
      return marker;
    }

    const markers = new Map();

    function applyState(list) {
      const alive = new Set();

      list.forEach(t => {
        alive.add(t.id);

        let marker = markers.get(t.id);
        if (!marker) {
          marker = createMarker(t);
          marker.addTo(map);
          markers.set(t.id, marker);
        } else {
          marker.setLatLng([t.lat, t.lon]);
        }

        // ОБЕРТАННЯ: dx/dy → кут, як домовлялись
        let angle = Math.atan2(t.dy, t.dx) * 180 / Math.PI;
        // 0° = вгору, а не вправо → 90 - angle
        angle = 90 - angle + (ROT_OFFSET[t.type] || 0);

        marker._imgRef.style.transform = `rotate(${angle}deg)`;
      });

      markers.forEach((m, id) => {
        if (!alive.has(id)) {
          map.removeLayer(m);
          markers.delete(id);
        }
      });
    }

    const ws = new WebSocket(
      (location.protocol === "https:" ? "wss://" : "ws://") + location.host
    );

    ws.onopen = () => console.log("WS viewer connected");
    ws.onmessage = ev => {
      let data;
      try { data = JSON.parse(ev.data); } catch { return; }

      if (data.type === "state" && Array.isArray(data.targets)) {
        applyState(data.targets);
      } else if (data.type === "alerts") {
        const list = data.alerts || data.regions || [];
        applyAlertsFromServer(list);
      }
    };
  </script>
</body>
</html>
